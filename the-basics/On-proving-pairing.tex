\subsection{On-proving-pairing}

This is a efficient ways to prove correctness of \cite{website:On-proving-pairing}, the algorithm shows in page 25:

Algorithm 9: Multi Miller loop with embedded $c$ exponentiation 

Input: $\displaystyle A = [(P_1,Q_1), (P_2,Q_2),...,(P_n,Q_n)],c, c^{-1} \in F_{q^k},s \in F_{q^3},P_{Q_j} \leftarrow \mathcal{L}(Q_j)$ 

Output: $\displaystyle 1 \ \ if \prod_{i=0}^{n}e(P_i, Q_i) = 1 $ 

(1) assert $\displaystyle c \cdot c^{-1} = 1 $ 

(2) $\displaystyle f \leftarrow c^(-1), lc \leftarrow 0 $ 

(3) Initialize array $T$ such that $\displaystyle T[j] = Q_j $ for each non-fixed point $Q_j$ 

(4) for $i$ = $L-2$ to $0$ do 

(5) \indent $f$ = $f^2$ 

(6) \indent for j=1 to n do 

(7) \indent \indent $\displaystyle l \leftarrow P_{Q_j}[lc] $ 

(8) \indent \indent $\displaystyle f = f \cdot l.evaluate(P_j) $  

(9) \indent \indent if $Q_j$ is not fixed then 

(10) \indent \indent \indent $\displaystyle T \leftarrow T[j] $ 

(11) \indent \indent \indent assert $\displaystyle l.is_tangent(T) $ 

(12) \indent \indent \indent $\displaystyle T[j] = l.double(T) $ 

(13) \indent \indent end 

(14) \indent \indent if $bit^2 == 1$ then 

(15) \indent \indent \indent $\displaystyle f = f \cdot c^{-1}$ if $bit$ == 1 else $\displaystyle f \cdot c$ end 

(16) \indent \indent \indent $\displaystyle l \leftarrow P_{Q_j}[lc+1] $ 

(17) \indent \indent \indent $\displaystyle f = f \cdot l.evaluate(P_{j})$ 

(18) \indent \indent \indent if $Q_j$ is not fixed then 

(19) \indent \indent \indent \indent $\displaystyle Q^{'} = Q_j $ if $bit$ == 1 else $\displaystyle -Q_j $ 

(20) \indent \indent \indent $\displaystyle T \leftarrow T[j] $ 

(21) \indent \indent \indent assert $\displaystyle l.is_line(T, Q^{'}) $ 

(22) \indent \indent \indent $\displaystyle T[j] = l.add(T, Q^{'}) $ 

(23) \indent \indent \indent end 

(24) \indent \indent end 

(25) \indent end 

(26) \indent $\displaystyle lc = lc + 2 $ 

(27) \indent for j=0 to n do 

(28) \indent \indent $\displaystyle f \leftarrow f \cdot s \cdot (c^{-1})^q \cdot (c^{-1})^{q^2} \cdot (c^{-1})^{q^3} $ 

(29) \indent \indent $\displaystyle l_{1..3} \leftarrow (P_{Q_j}[lc+i])_{i=0}^2 $ 

(30) \indent \indent $\displaystyle f \leftarrow f \cdot l_1.evaluate(P_{j}) \cdot l_2.evaluate(P_{j}) \cdot l_3.evaluate(P_{j}) $ 

(31) \indent \indent if $Q_j$ is not fixed then 

(32) \indent \indent \indent $\displaystyle Q_1 \leftarrow \pi_p(Q), Q_12\leftarrow \pi_p(Q_1), Q_3 \leftarrow \pi_p(Q_2) $ 

(33) \indent \indent \indent $\displaystyle T \leftarrow T[j] $ 

(34) \indent \indent \indent assert $\displaystyle l_1.is_line(T, Q_1); T \leftarrow T + Q_1 $ 

(35) \indent \indent \indent assert $\displaystyle l_2.is_line(T, -Q_2); T \leftarrow T - Q_1 $ 

(36) \indent \indent \indent assert $\displaystyle l_3.is_line(T, Q_3) $ 

(37) \indent \indent end 

(38) \indent end 

(39) end 

(40) return $\displaystyle f == 1? $ 


if We adopt this algorithm into Groth16, The whole algorithm process should be like this:

$\displaystyle P_1 = [msm]_1; Q_1 = -[\gamma]_2 $

$\displaystyle P_2 = [C]_1; Q_2 = -[\delta]_2 $

$\displaystyle P_3 = [\alpha]_1; Q_3 = -[\beta]_2 $

$\displaystyle P_4 = [A]_1; Q_4 = [B]_2 $


$Q_4$ is non-fixed, $Q_1$, $Q_2$, and $Q_3$ is fixed.


Input: $\displaystyle A = [(P_1,Q_1), (P_2,Q_2), (P_3,Q_3),(P_4,Q_4)],c, c^{-1} \in F_{q^k},s \in F_{q^3},P_{Q_4} \leftarrow \mathcal{L}(Q_4)$ 

Output: $\displaystyle 1 \ \ if \prod_{i=0}^{n}e(P_i, Q_i) = 1 $ 

(1) assert $\displaystyle c \cdot c^{-1} = 1 $ 

(2) $\displaystyle f \leftarrow c^(-1), lc \leftarrow 0 $ 

(3) Initialize array $T$ such that $\displaystyle T[j] = Q_j $ for each non-fixed point $Q_j$ 

(4) for $i$ = $L-2$ to $0$ do 

(5) \indent $f$ = $f^2$ 

(6) \indent \indent $\displaystyle f = f \cdot c^{-1}$ if $bit$ == 1 else $\displaystyle f \cdot c$ end 

(7) \indent for j = 1 to 4 do 

(7) \indent \indent $\displaystyle l \leftarrow P_{Q_j}[lc] $ 

(8) \indent \indent $\displaystyle f = f \cdot l.evaluate(P_j) $  

(8) \indent end 

(9) \indent $Q_4$ is not fixed then 

(8) \indent $\displaystyle f = f \cdot l.evaluate(P_4) $  

(10) \indent $\displaystyle T \leftarrow T[j] $ 

(11) \indent assert $\displaystyle l.is_tangent(T) $ 

(12) \indent $\displaystyle T[j] = l.double(T) $ 

(14) \indent if $bit == 1$ or $bit == -1 $ then 

(7) \indent \indent for j = 1 to 4 do 

(7) \indent \indent \indent $\displaystyle l \leftarrow P_{Q_j}[lc + 1] $ 

(8) \indent \indent \indent $\displaystyle f = f \cdot l.evaluate(P_j) $  

(8) \indent \indent end 

(18) \indent \indent $Q_4$ is not fixed then 

(16) \indent \indent  $\displaystyle l \leftarrow P_{Q_j}[lc+1] $ 

(17) \indent \indent  $\displaystyle f = f \cdot l.evaluate(P_{j})$ 

(19) \indent \indent  $\displaystyle Q^{'} = Q_j $ if $bit$ == 1 else $\displaystyle -Q_j $ 

(20) \indent \indent  $\displaystyle T \leftarrow T[j] $ 

(21) \indent \indent  assert $\displaystyle l.is_line(T, Q^{'}) $ 

(22) \indent \indent  $\displaystyle T[j] = l.add(T, Q^{'}) $ 

(24) \indent  end 

(28) \indent  $\displaystyle f \leftarrow f \cdot s \cdot (c^{-1})^q \cdot c^{q^2} $ 

(7) \indent \indent for j = 1 to 4 do 

(30) \indent \indent $\displaystyle f \leftarrow f \cdot l_1.evaluate(P_{j}) $ 

(7) \indent \indent end 

(31) \indent \indent $Q_4$ is not fixed then 

(32) \indent \indent  $\displaystyle Q_1 \leftarrow \pi_p(Q), Q_12\leftarrow \pi_p(Q_1), Q_3 \leftarrow \pi_p(Q_2) $ 

(33) \indent \indent  $\displaystyle T \leftarrow T[j] $ 

(34) \indent \indent  assert $\displaystyle l_1.is_line(T, Q_1); T \leftarrow T + Q_1 $ 

(35) \indent \indent  assert $\displaystyle l_2.is_line(T, -Q_2); T \leftarrow T - Q_1 $ 

(36) \indent \indent  assert $\displaystyle l_3.is_line(T, Q_3) $ 

(38) \indent end 

(39) end 

(40) return $\displaystyle f == 1? $ 